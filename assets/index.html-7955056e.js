import{_ as e,M as p,p as o,q as a,R as i,t as l,N as n,a1 as c}from"./framework-5866ffd3.js";const s={},d=i("h1",{id:"git-命令",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#git-命令","aria-hidden":"true"},"#"),l(" git 命令")],-1),r=i("h2",{id:"linux常用命令",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#linux常用命令","aria-hidden":"true"},"#"),l(" Linux常用命令")],-1),g={href:"http://docs.lipeihua.vip/#/./git%E6%95%99%E7%A8%8B/01.git%E5%87%86%E5%A4%87?id=_411-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4",target:"_blank",rel:"noopener noreferrer"},u=c(`<p>Linux是一套开源免费的操作系统，与系统的交互通常用命令来实现，常用的命令有：</p><ul><li><p><code>ls</code> 查看当前文件夹下的文件（list单词的缩写）， <code>ls -al </code> or <code>ls -a -l</code>查看隐藏文件并竖向排列</p></li><li><p><code>cd</code> 进入某一个文件夹（change directory）的缩写，<code>cd ..</code>回到上一级。<code>tab</code>键代码自动补全</p></li><li><p><code>clear</code> 清屏</p></li><li><p><code>mkdir</code> 创建文件夹</p></li><li><p><code>touch test.html</code> 创建一个文件</p></li><li><p><code>rm test.html</code> 删除一个文件</p></li><li><p><code>rm -r dir</code> 删除文件夹</p></li><li><p><code>mv 原文件或文件夹 目标文件或文件夹</code> 移动文件</p></li><li><p><code>cat test.html</code> 查看文件内容</p></li><li><p><code>ctrl+c</code> 取消命令</p></li><li><p>上下方向键，可以查看命令历史</p><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code>练习：创建一下目录结构
*project
    <span class="token list punctuation">-</span> css
        <span class="token list punctuation">-</span> app.js
        <span class="token list punctuation">-</span> home.js
    <span class="token list punctuation">-</span> js
        <span class="token list punctuation">-</span> app.js
    <span class="token list punctuation">-</span> images
        <span class="token list punctuation">-</span> logo.png
    <span class="token list punctuation">-</span> index.htmlCopy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="vim编辑器" tabindex="-1"><a class="header-anchor" href="#vim编辑器" aria-hidden="true">#</a> Vim编辑器</h3><p>Vim是一款命令行下的文本编辑器，编辑方式跟图形化编辑器不同</p><ul><li><code>vim test.html</code>编辑文件（文件不存在则创建）</li><li>i 可以进入编辑模式</li><li><code>ESC</code> + <code>:wq</code> 保存并推出</li><li><code>ESC</code>+<code>:q!</code> 不保存并推出</li></ul><h2 id="git命令" tabindex="-1"><a class="header-anchor" href="#git命令" aria-hidden="true">#</a> git命令</h2><ul><li><p>git init 初始化仓库</p></li><li><p><code>git init name</code> 在当前目录下创建一个名字叫做name的仓库，需要使用<code>cd name</code>进入仓库后操作</p></li><li><p>git status 查看文件的状态</p><ul><li>红色：工作区修改新增删除等操作，没有提交到暂存区</li></ul></li><li><p>git add .(*) :提交所有的工作区修改到暂存区 git add 文件名：把某个文件提交到暂存区</p></li><li><p>git commit -m &#39;注释信息&#39;：把暂存区的内容 提交到了仓库区，生成一个新的版本</p></li><li><p>git commit -am ’注释信息‘：可以自动直接把工作区修改提交到暂存区并提交到仓库生成新的版本（只能操作修改的文件，新增文件是不能直接这样操作的）</p></li><li><p>git commit 直接进入到vim中书写注释信息，并且提交到仓库区</p></li><li><p>git restore 文件名/. 撤销工作区的修改 恢复到上一次的提交</p></li><li><p>git restore --staged ./文件名 撤销暂存区的修改，回退到工作修改</p></li><li><p>新增文件不能使用git restore撤回，直接删除即可</p><blockquote><p>没有提交过版本就不能撤回</p></blockquote></li><li><p>git rm 文件 ：删除了工作区和暂存区的文件</p></li><li><p>git rm --cached 文件：删除了暂存区的文件</p></li><li><p>git rm -f 文件：当工作区和暂存区不一致的时候，强制删除工作区和暂存区中的某个文件</p></li><li><p>git mv 01.txt 02.txt:把工作区和暂存区的01.txt命名为02.txt</p></li><li><p>git log ：打印所有的历史操作</p></li><li><p>git log --oneline 打印所有历史操作 简略显示</p></li><li><p>git log -p 展示历史操作及差异</p></li><li><p>git log -p -2 展示历史操作及差异 最近两次</p></li><li><p>git diff 查看工作区和暂存区的差异 （无法比较新增文件）</p></li><li><p>git diff --cached 比较暂存区和仓库区最新版本的差异</p></li><li><p>git diff a b 比较两个版本的差异</p></li><li><p>git reset --hard/--mixed/--soft 版本号：回退到某个版本号</p><ul><li>--hard 版本区回退 重置工作区和暂存区</li><li>--mixed 版本去回退 重置暂存区</li><li>--soft 版本区回退 不会重置工作区和暂存区</li></ul></li><li><p>git reflog --oneline ：查看所有的提交及回退操作</p></li><li><p>git reset --hard HEAD^:一个^代表回退一个</p></li><li><p>git reset --hard HEAD~2:~后边的数字代表回退几个</p></li><li><p>配置忽略：</p><ul><li>如果是一个只存在工作区的文件，则直接使用.gitignore配置会略即可</li><li>如果仓库已经提交了当前的文件，则先把暂存区的被忽略的文件删除（git rm --cached 文件：删除了暂存区的文件），把删除被忽略文件后的暂存区提交给仓库区，此时工作区的这个文件就是未跟踪状态，可以再去配置忽略</li></ul></li><li><p>git branch 分支名：创建分支</p></li><li><p>git branch：查看所有分支及当前所在分支</p></li><li><p>git checkout 分支名：切换某个分支（切换分支前一定要提交当前的代码）</p></li><li><p>git checkout -b 分支名：创建并切换到某个分支</p></li><li><p>git checkout -B 分支名：创建并切换分支，但是如果已经有同名分支 则直接强制覆盖</p></li><li><p>git checkout -b 分支名 commitID：从指定的版本创建分支</p></li><li><p>git checkout --orphan 分支名：创建一个裸分支</p></li><li><p>git branch -d 分支名 ：删除某个分支</p></li><li><p>git branch -D 分支名 ：强制删除某个分支</p></li><li><p>git merge 分支名：合并其他分支</p></li></ul><ol><li>项目经理创建文件架构</li><li>项目经理创建B和A分支</li><li>B开发 并提交</li><li>A开发并提交</li><li>到主分支上 分别合并B和A分支 （如果出现冲突 则需要解决冲突，解决完冲突 切记要提交）</li><li>B上班了，首先要把主分支的代码合并到自己的分支上</li><li>A上班了，首先要把主分支的代码合并到自己的分支上</li><li>。。。。。</li></ol><p>本地有仓库，远程没有仓库</p><ul><li><p>创建远程仓库</p></li><li><p>git remote add origin 仓库地址：把本地仓库和远程仓库进行关联</p></li><li><p>git push -u origin master 推送master分支</p></li><li><p>git push -u origin --all 推送所有的分支</p><blockquote><p>-u 参数的作用是跟踪后面出现的远程仓库的分支，后续直接使用git push就可以将代码推送到该分支</p></blockquote></li></ul><p>git remote：展示当前本地仓库关联的所有的远程仓库</p><p>git remote rm 别名：删除某个关联</p><p>git clone 地址：克隆远程仓库</p><p>git pull origin master:更新master分支（一般在推送之前先拉取更新，然后处理冲突之后再推送，否则推送可能失败）</p><p>git push origin master（拉取更新处理冲突之后，提交到本地仓库 然后再推送到远程仓库）</p><p>git pull origin B:B: 在本地创建一个B分支 然后拉取B分支到本地</p><ul><li>项目组长在本地创建的项目的架构，并创建远程仓库 推送远程仓库 <ul><li>git init 初始化本地仓库</li><li>git add . git commit -m ‘初始化’：把本地初始化代码提交到本地仓库</li><li>git remote add origin 地址：把本地仓库和远程仓库关联</li><li>git push origin master ：把本地仓库的master分支推送到远程仓库</li><li>git branch B git branch A ：在本地创建B和A分支</li><li>git push origin --all 把本地所有的分支都推送到远程仓库</li></ul></li><li>B从远程仓库拉取代码，在自己的分支上进行开发工作 <ul><li>git clone XXX：先克隆远程代码</li><li>git pull origin B:B ：拉取B分支</li><li>git checkout B：要切换到B分支 开始工作</li><li>git add . git commit -m &#39;XX&#39;：当B分支开发完毕，提交本地的B分支</li><li></li></ul></li><li>A从远程仓库拉取代码 在自己的分支上进行开发换工作 <ul><li>git clone XXX：先克隆远程代码</li><li>git pull origin A ：拉取A分支</li><li>git checkout A：要切换到A分支 开始工作</li><li>git add . git commit -m &#39;XX&#39;：当A分支开发完毕，提交本地的A分支</li></ul></li><li>B和A开发完成之后，把自己的代码推送到远程仓库 <ul><li>git push origin B：把自己的分支修改推到远程 然后下班</li><li>git push origin A：把自己的分支修改推到远程 然后下班</li></ul></li><li>项目组长合并B和A的代码，并更新至远程仓库 <ul><li>git pull origin B：拉取B分支的更新 并合并到master上</li><li>git pull origin A：拉取A分支的更新，并合并到master</li><li>git add . git commit -m &#39;xXX&#39;:合并分支 的时候可能会出现冲突，解决完冲突之后，要处理冲突并重新提交</li><li>git push origin master：把最新的合并的完成代码推送到远程仓库</li></ul></li><li>B和A第二天上班 拉取新的代码，然后继续各自开发 <ul><li>git pull origin master：在各自的分支上拉取master的更新，并且直接合并到自己的代码中，然后可以开始第二天的开发</li></ul></li></ul><p>在主分支的基础上，新建了其他分支，进行修改，改完之后，切回主分支，发现主分支的内容也被修改，反复切换分支，发现分支确实切换了，但是内容显示的确实新建分支的内容，难道主分支也同步被修改了？答案是：没有修改，原因是我们在新建的分支上做了修改之后没有做提交版本，现在只需要切换到新建的分支，对当前的修改做一次提交，问题就解决了！</p><p>冲突：简单来说就是本地修改的文件和目标远程库的同一个文件都有修改。这时无论是pull丶push丶merge时都会产生冲突。</p><p>冲突的根本其实就是一个版本在前了，一个版本在后了，merge的时候又想把前版本合并到后版本去，肯定会存在冲突，就像过去的东西你能随便拿到现在使用吗，是一样的道理</p><p>举例： 1.不同分支下的merge 比如在不同分支下进行分支合并时，我们在本地修改了a文件并把a文件的修改push到了test分支下，接着我们切换到master分支下将test分支上的修改合并到当前master分支下时，如果master分支下的a文件也有修改的话，这时在进行merge也会产生冲突。（因为这个两个分支是不同步的，两个分支下的同一个文件都有修改） 2.同一个分支下的pull或push 比如在同一个分支下，对本地的a文件做出了修改，此时我们在进行pull或push时如果远程分支下下的a文件也有修改，那么代表本地和远程分支的代码是不同步的，此时也会引起冲突。</p><p>使用idea解决冲突的步骤 1.首先pull操作，如果有冲突会提示需要合并冲突，不过此时只能只能单向同步。（比如只能将远程的代码覆盖到本地） 2.以此执行add commit pull命令，此时就会显示双向同步的界面，此时解决完冲突并点击apply后，就会自动将远程的代码拉到本地，然后我们在重新push我们本地的代码到远程分支即可。</p>`,22);function m(h,v){const t=p("ExternalLinkIcon");return o(),a("div",null,[d,r,i("p",null,[i("a",g,[l("链接地址"),n(t)])]),u])}const b=e(s,[["render",m],["__file","index.html.vue"]]);export{b as default};
